#!/usr/bin/env ruby

# frozen_string_literal: true

require 'active_support/core_ext/string/filters' # for `#squish`
require 'listen'

last_file_update = Time.now
listener =
  Listen.to("#{Dir.pwd}/personal/", only: /\A.*\.rb\z/) do |_modified, _added, _removed|
    # Don't enter infinitely recursive loop, since the code below triggers file updates.
    # After file has been updated, wait at least 0.5 seconds before listener processes again.
    next if (Time.now - last_file_update) < 0.5

    puts('Running code...')
    all_code = File.read('personal/ruby.rb')
    non_printed_code = all_code[/\A.*############\n\n/m]
    printed_code = all_code.delete_prefix(non_printed_code)
    printed_code_segments = printed_code.scan(/(?:(?!\n))(?:(?!###|# =>).)*(?:# =>|###)[^\n]*\s*/mi)

    known_erroring_segment_indexes = []
    random_seed = rand(1_000_000_000)
    printed_code_segments.each_with_index do |printed_code_segment, index|
      indexes_to_eval =
        (0..index).to_a.reject { |idx| known_erroring_segment_indexes.include?(idx) }
      groups_to_eval = [non_printed_code] + printed_code_segments.values_at(*indexes_to_eval)

      result = ':NONE:'
      begin
        code_to_eval = groups_to_eval.join('')
        # we need to namespace any constants that would otherwise persist between "save sessions"
        namespace = Module.new
        namespace.instance_eval { srand(random_seed) }
        $printed_objects_last_run ||= []
        $printed_objects = []
        result = namespace.instance_eval(code_to_eval).inspect.squish
        # result = eval(code_to_eval).inspect.squish
        newly_printed_objects = $printed_objects - $printed_objects_last_run
        if newly_printed_objects.any?
          result = %(prints "#{newly_printed_objects.first}")
        end
        $printed_objects_last_run = $printed_objects
      rescue => error
        puts('ERROR:')
        p(error)
        result = "raises #{error.class}"
        known_erroring_segment_indexes << index
      end

      printed_code[printed_code_segment] =
        printed_code_segment.sub(/(?:# =>|###)[^\n]*$/, "# => #{result}")
    end

    $printed_objects_last_run = []
    puts("Writing file! #{Time.now}")
    last_file_update = Time.now
    File.write('personal/ruby.rb', non_printed_code + printed_code)
  end

listener.start
system('clear')
puts('Waiting for a file save...')

at_exit do
  print('Stopping listener ... ')
  listener.stop
  puts('done.')
end

sleep
